---
title: "4.1.3. 发送和接收握手消息"
anchor: "4.1.3_Sending_and_Receiving_Handshake_Messages"
weight: 413
rank: "h3"
---

为了进行握手，TLS需要发送和接收握手消息的能力。对于这个接口，有两个基本函数：QUIC从其中一个函数获取握手消息，向另一个函数提供组成握手消息的字节数据。

在启动握手前，QUIC向TLS提供它想传递的传输参数（详见[第8.2章](#8.2_QUIC_Transport_Parameters_Extension)）。

QUIC客户端以向TLS获取握手的字节数据的方式启动TLS。客户端在发送首个数据包前获取握手的字节数据。QUIC服务器则以向TLS提供客户端的握手字节数据的方式启动TLS。

任一终端的TLS栈都始终记录着当前的发送密级和接收密级。TLS密级决定了QUIC数据包类型和用于保护数据的密钥。

每个密级都关联着各自的一份字节序列，这些字节内容会由**加密帧**可靠地发送给对端。当TLS提供了将要发送的握手字节时，这些字节会被追加到当前密级的握手字节内容后面。该密级决定着最终发送**加密帧**时所用的数据包类型；详见[表1](#Table_1_Encryption_Keys_by_Packet_Type)。

四个密级分别为初始数据包、0-RTT数据包、握手数据包和1-RTT数据包生成密钥。其中只有三个密级能被用来传递**加密帧**，不在其中的是0-RTT这个密级。这四个密级对应着三个数据包号空间：受初始密钥和握手密钥加密的数据包分别使用各自的空间；0-RTT数据包和1-RTT数据包使用应用数据数据包号空间。

QUIC使用未受保护的TLS握手记录的内容作为**加密帧**的内容。QUIC不使用TLS的记录保护。QUIC将**加密帧**组装进具有QUIC数据包保护的QUIC数据包。

QUIC**加密帧**仅传递TLS握手消息。TLS警告被转换为QUIC**连接关闭帧**的错误码；详见[第4.8章](#4.8_TLS_Errors)。TLS应用数据和其他内容类型不能由QUIC以任何密级传递；不应该从TLS栈接收到它们，否则这是一种错误。

当终端从网络接收到了一个包含**加密帧**的QUIC数据包时，它应该这样处理：

* 如果数据包使用了当前的TLS接收密级，那么数据会被正常地按顺序置入输入流。和**流帧**一样，要使用偏移值来在数据序列中找到正确的置入位置。如果完成该过程后出现了新的可用数据，那么新数据会被有序地交付给TLS。

* 如果数据包来自之前使用过的密级，那么它包含的数据{{< req_level MUST_NOT >}}扩展那个密级的数据流末尾。QUIC实现{{< req_level MUST >}}将任何违反这项要求的情况视作类型为`PROTOCOL_VIOLATION`（协议违反）的连接错误。

* 如果数据包来自新的密级，那么它会被保存起来，用于将来给TLS处理。一旦TLS改用此密级接收数据，暂存着的数据就可以被交给TLS。当TLS为更高的密级提供密钥时，如果还有来自之前的密级但是还未被TLS处理的数据，那么{{< req_level MUST >}}将该情况视作类型为`PROTOCOL_VIOLATION`的连接错误。

每次将新数据交给TLS时，都会向TLS获取新的握手字节。如果TLS接收到的握手消息不完整或它没有数据需要发送，那么它可能不会提供任何字节数据。

**加密帧**的内容可能会被TLS增量处理，或被缓存起来直到有完整的可用消息。TLS负责缓存按序到达的握手字节数据。QUIC负责缓存未按序到达或属于尚未可用的密级的握手字节。QUIC不会为**加密帧**提供任何流量控制的方法；详见《[QUIC传输](../RFC9000_Chinese_Translation)》的[第7.5章](../RFC9000_Chinese_Translation/#7.5_Cryptographic_Message_Buffering)。

一旦TLS握手完成，这一事件就会随着TLS要发送的最后的握手字节一起被告知给QUIC。在这个阶段，握手期间对端宣告的传输参数会被验证；详见[第8.2章](#8.2_QUIC_Transport_Parameters_Extension)。

一旦握手完成，TLS就变得被动起来。TLS仍然可以从对端接收数据并作出响应，但它没有必要发送更多数据，除非被应用或QUIC专门提出要发送数据的请求。发送数据的可能原因之一是服务器可能想要向客户端新增或更新会话票据。

当握手完成后，QUIC只需要向TLS提供以**加密帧**的形式到达的数据。和握手期间的行为一样，处理完接收到的数据后QUIC会向TLS获取新数据。
