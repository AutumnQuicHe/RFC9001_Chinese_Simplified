---
title: "4.1.4. 改变密级"
anchor: "4.1.4_Encryption_Level_Changes"
weight: 414
rank: "h3"
---

当某个密级的密钥对TLS可用时，TLS会告知QUIC那个密级的读取密钥或写入密钥已经变为可用了。

新密钥变为可用这一事件一定是因向TLS提供输入而引发的。TLS只有在（被客户端）初始化后或接收到新握手数据时才会提供新密钥。

然而，TLS实现可能会异步地进行某些处理过程。尤其是，验证证书的过程可能会花不少时间。当等待TLS处理时，如果终端接收到了需要用尚未可用的密钥来处理的数据包，那么终端{{< req_level SHOULD >}}将它们缓存起来。一旦TLS提供了密钥，这些数据包就能够得到处理。终端{{< req_level SHOULD >}}继续响应此时可以处理的数据包。

在处理完输入后，TLS可能生成出握手字节、新密级的密钥或两者兼具。

当新密级可用时，TLS会向QUIC提供以下三份内容：

* 一个秘密值

* 一个带有关联数据的认证加密（AEAD）函数

* 一个密钥衍生函数（KDF）

这些值源自TLS协商出的那些值，以及被QUIC用于生成数据包与头部保护密钥的那些值；详见[第5章](#5_Packet_Protection)和[第5.4章](#5.4_Header_Protection)。

如果要使用0-RTT，那么0-RTT会在客户端发送了TLS的`ClientHello`消息或服务器接收到这条消息后就绪。在第一次向QUIC提供握手字节后，TLS栈可能会发送有关0-RTT密钥发生变化的信号。在服务器接收到包含`ClientHello`消息的握手字节后，TLS服务器可以发送有关0-RTT密钥变为可用的信号。

尽管TLS在某一时刻只会使用一个密级，QUIC却可以同时使用不止一个密级。举例来说，终端在发送完`Finished`消息后（使用的是处于握手密级的**加密帧**），它可以发送**流帧**（使用的是1-RTT加密）。如果`Finished`消息在传输过程中被丢失了，那么终端会用握手密级重传丢失的消息。数据包乱序或丢包的存在意味着QUIC可能需要同时处理处于不同密级的数据包。在握手期间，这意味着有可能需要处理位于比TLS正在使用的密级更高或更低的密级的数据包。

特别是，服务器上的QUIC实现需要有能力同时读取位于握手密级和位于0-RTT密级的数据包。客户端可能使0-RTT数据与受握手密钥保护的**ACK帧**交错传输，而服务器得处理这些确认才能检测出丢包的握手数据包。

QUIC还需要访问对TLS实现来说并不可用的密钥。例如，客户端可能需要在准备好发送握手密级的**加密帧**前确认握手数据包。因此TLS可能需要在出于自己使用的目的而生成密钥前就向QUIC提供这些密钥。
