---
title: "6.1. 发起密钥更新"
anchor: "6.1_Initiating_a_Key_Update"
weight: 610
rank: "h2"
---

终端为数据包保护维护着相互独立的读取秘密值和写入秘密值。终端通过更新数据包的写入秘密值并用它去保护新数据包的方式来发起密钥更新。终端如《[TLS13]()》的[第7.2章]()中所展示的那样，从已有的写入秘密值创建新的写入秘密值。这会用到由TLS提供的KDF函数和值为`quic ku`的标签。该秘密值会如[第5.1章]()中所述的那样，创建出相应的密钥和IV。而头部保护密钥不会被更新。

举个例子，在使用TLS 1.3时，为了更新写入密钥，要这样使用`HKDF-Expand-Label`：

{{% block_ref
indx="Pseudocode_6_1_1" %}}

```
secret_<n+1> = HKDF-Expand-Label(secret_<n>, "quic ku",
                                 "", Hash.length)
```

{{% /block_ref %}}

终端会切换密钥阶段比特位的状态，并将更新后的密钥和IV用于保护后续数据包。

在握手已确认（详见[第4.1.2章]()）前，终端{{< req_level MUST_NOT >}}发起密钥更新。在终端接收到对于受当前密钥阶段的密钥保护的数据包的确认前，它{{< req_level MUST_NOT >}}发起后续的密钥更新。这确保了再一次发起密钥更新前，当前密钥在两侧终端处均为可用状态。要做到这一点，可以追踪用各个密钥阶段的密钥发送的最小数据包号，以及在1-RTT空间中的最大已确认数据包号：一旦后者大于等于前者，就可以再发起一次密钥更新。

> 注意：非1-RTT数据包的密钥从不会被更新；它们的密钥一定是从TLS握手状态中衍生出来的。

发起密钥更新的终端还会更新用于接收数据包的密钥。这些密钥会在更新后被用于处理对端发送的数据包。

在成功移除了使用新密钥发送的数据包的保护前，终端{{< req_level MUST >}}保留旧密钥。在成功移除了使用新密钥发送的数据包的保护后，终端{{< req_level SHOULD >}}将旧密钥保留一段时间。过早地弃用旧密钥会导致延误的数据包被丢弃。丢弃数据包的行为会被对端当作数据包遭遇了丢包，反而会影响性能。
