---
title: "6.2. 响应密钥更新"
anchor: "6.2_Responding_to_a_Key_Update"
weight: 620
rank: "h2"
---

在接收到对于受当前密钥阶段的密钥保护的数据包的确认后，对端就可以发起密钥更新。终端在处理到一个密钥阶段的值与它曾发出的最后一个数据包中的值不同的数据包时，会将该情况视作为密钥更新。为了处理这个数据包，终端要使用下一阶段中的数据包保护密钥和IV。有关创建这些密钥时的考量，详见[第6.3章]()。

如果某个数据包可以使用下一阶段中的密钥和IV来处理，就说明对端发起了密钥更新。作为响应，终端{{< req_level MUST >}}将它的发送密钥更新到相应的密钥阶段，如[第6.1章]()所述。在发送对于使用了更新后的密钥来接收的数据包的确认前，{{< req_level MUST >}}更新发送密钥。通过用受更新后的密钥保护的数据包来确认触发密钥更新的数据包的方式，终端发送出密钥更新完成的信号。

终端可以根据自己平时的数据包发送习惯，推迟发送数据包或确认：没有必要为了响应密钥更新而立即创建新数据包。终端发送的下一个数据包会用上更新后的密钥。下一个包含确认的数据包会使得密钥更新完成。如果终端检测到了第二次密钥更新，但它这时还没有使用更新后的密钥发送包含对于触发前一次密钥更新的数据包的响应的数据包，那么这就表明对端没有等待确认就更新了密钥两次。终端{{< req_level MAY >}}将这样的连续密钥更新行为视作类型为`KEY_UPDATE_ERROR`（密钥更新错误）的连接错误。

如果终端接收到的确认来自受旧密钥保护的数据包，但确认是对于受新密钥保护的数据包的，那么它{{< req_level MAY >}}将这种情况视作类型为`KEY_UPDATE_ERROR`的连接错误。这表明对端已经接收到并且确认了发起密钥更新的数据包，但是在响应时没有更新密钥。
