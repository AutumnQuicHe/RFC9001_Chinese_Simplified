---
title: "6.5. 使用不同的密钥来接收"
anchor: "6.5_Receiving_with_Different_Keys"
weight: 650
rank: "h2"
---

在密钥更新期间，可能会接收到受旧密钥保护的数据包，它们因为被网络延误而刚刚抵达。保留旧的数据包保护密钥使得这些数据包能够被成功处理。

由于受来自下一阶段的密钥保护的数据包会与受来自上一阶段的密钥保护的数据包使用相同的密钥阶段，要想处理受旧密钥保护的数据包，就有必要区分这两种数据包。这可以通过使用数据包号来做到。如果重建出来的数据包号比当前密钥阶段的任一数据包号要小，那么这些数据包就要使用上一阶段的数据包保护密钥；如果重建出来的数据包号比当前密钥阶段的任一数据包号要大，那么这些数据包就要使用下一阶段的数据包保护密钥。

为了确保在上一阶段、当前阶段和下一阶段的数据包保护密钥间选择的过程不会在计时侧信道上泄露最终用于移除数据包保护的是哪一组密钥，必须谨慎操作。有关更多信息，详见[第9.5章](#9.5_Header_Protection_Timing_Side_Channels)。

作为替代方案，终端可以仅维护两组数据包保护密钥，只需在经过对网络重排序来说充足的时间后将上一阶段的密钥替换为下一阶段的密钥。在这种情况下，只需要密钥阶段比特位就足以选择密钥。

在将下一阶段的接收密钥提升为当前阶段后，终端{{< req_level MAY >}}在建立再下一组数据包保护密钥前等待一段约为一个探测包超时（PTO；详见《[QUIC恢复](../RFC9002_Chinese_Translation)》）的时间。这组被推迟建立的新密钥{{< req_level MAY >}}在经过这段等待时间后才替换上一阶段的旧密钥。只不过有一个缺点，即PTO是一个主观的测量结果——也就是说，对端对于RTT的预估可能不同——这段等待时间既应该足够长以使得所有乱序数据包哪怕被确认了也都会被对端认定为丢包，又应该足够短以使得对端可以发起后续的密钥更新。

在对端保留旧密钥期间，对端可能无法解密发起密钥更新的数据包，终端需要允许这种情况的存在。在接收到能够表明先前的密钥更新已经被接收到的确认后，终端在发起密钥更新前{{< req_level SHOULD >}}等待一段时长为PTO三倍大小的时间。若没有留足时间，可能导致数据包被丢弃。

在接收到受新密钥保护的数据包后，终端保留旧的读取密钥的时长{{< req_level SHOULD >}}不超过PTO的三倍。在这段等待时间之后，旧的读取密钥和它们对应的秘密值{{< req_level SHOULD >}}被弃用。
