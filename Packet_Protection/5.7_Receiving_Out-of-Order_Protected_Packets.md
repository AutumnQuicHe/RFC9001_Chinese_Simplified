---
title: "5.7. 接收乱序的受保护数据包"
anchor: "5.7_Receiving_Out-of-Order_Protected_Packets"
weight: 570
rank: "h2"
---

因为有乱序和丢包的情况存在，受保护的数据包可能在终端接收到最后的TLS握手消息前就被接收到了。这时客户端还无法解密来自服务器的1-RTT数据包，或服务器还无法解密来自客户端的1-RTT数据包。任一终端{{< req_level MUST_NOT >}}在握手完成前解密来自对端的1-RTT数据包。

即使服务器在接收到来自客户端的首条握手消息后就能建立1-RTT密钥，但它还不能确信此时客户端的状态：

* 客户端还未经验证，除非服务器愿意接受预共享密钥并且已经验证过了客户端的预共享密钥绑定；详见《[TLS13](https://www.rfc-editor.org/info/rfc8446)》的[第4.2.11章](https://www.rfc-editor.org/rfc/rfc8446.html#section-4.2.11)。

* 客户端还未表现出活动的迹象，除非服务器已经用重试数据包或其他手段验证了客户端的地址；详见《[QUIC传输](../RFC9000_Chinese_Translation)》的[第8.1章](../RFC9000_Chinese_Translation/#8.1_Address_Validation_during_Connection_Establishment)。

* 服务器准备对之响应的任何0-RTT数据都有可能是由重放攻击制造的。

因此，服务器在握手完成前对1-RTT密钥的使用目的受限为数据的发送。服务器在TLS握手完成前{{< req_level MUST_NOT >}}处理传入的受1-RTT密钥保护的数据包。因为发送确认就表明数据包中的所有帧都已经被处理了，所以服务器在TLS握手完成前不能发送对1-RTT数据包的确认。已接收到的受1-RTT密钥保护的数据包{{< req_level MAY >}}被存储起来，在将来握手完成时再解密和使用它们。

> 注意：TLS的实现可能会在握手完成前就提供所有1-RTT秘密值。在握手完成前，QUIC的实现即使获得了1-RTT读取密钥，也不能使用这些密钥。

服务器必须等待客户端的`Finished`（已结束）消息的这项要求意味着服务器依赖于那条消息被成功交付到服务器。客户端可以避免这种依赖暗含的队头阻塞问题，方法是将它的1-RTT数据包和一个包含着携带`Finished`消息的**加密帧**的握手数据包合并，直到其中一个握手数据包被确认。这使得服务器可以立即处理那些数据包。

服务器可能在接收到TLS的`ClientHello`前就接收到受0-RTT密钥保护的数据包。服务器{{< req_level MAY >}}保留这些数据包，并期待能接收到`ClientHello`以将它们解密。

客户端通常会在握手完成的同时得到1-RTT密钥。即使它拥有1-RTT的秘密值，客户端也{{< req_level MUST_NOT >}}在TLS握手完成前处理传入的受1-RTT密钥保护的数据包。
